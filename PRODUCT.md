# SW Runtime 功能说明文档

## 产品概述

SW Runtime 是一款基于 Go 语言开发的企业级 JavaScript/TypeScript 运行时环境，采用纯 Go 实现的 goja 引擎执行 JavaScript 代码，无需依赖 Node.js 即可运行脚本程序。产品设计目标是提供轻量级、高性能、可独立部署的 JavaScript 运行时解决方案，适用于微服务、嵌入式脚本、自动化工具、数据处理等多种应用场景。

本产品采用模块化架构设计，内置丰富的企业级功能模块，包括网络通信、数据库访问、加密解密、压缩解压等，开发者可以直接使用熟悉的 JavaScript/TypeScript 语法编写服务端应用，享受与 Node.js 相似的开发体验，同时获得更小的部署包体积和更低的运行时资源占用。

---

## 核心功能特性

### 1. 多语言脚本支持

SW Runtime 支持直接运行 JavaScript 和 TypeScript 两种脚本格式。JavaScript 文件以 `.js` 为扩展名，TypeScript 文件以 `.ts` 为扩展名。对于 TypeScript 文件，运行时内置了基于 esbuild 的即时编译器，会在执行前自动将 TypeScript 代码编译为 JavaScript，无需开发者手动预处理。这一特性使得团队可以直接使用类型安全的 TypeScript 进行开发，享受静态类型检查带来的代码质量提升，同时保持与纯 JavaScript 项目相当的运行效率。

运行时还支持 ES6 模块语法，包括 `import` 导入语句和 `export` 导出语句，开发者可以按照现代 JavaScript 项目的标准实践组织代码结构。对于 CommonJS 风格的 `require()` 函数调用，运行时同样提供了完整支持，确保向后兼容传统的 JavaScript 代码库。

### 2. 事件循环与异步编程

运行时内置了完整的事件循环实现，支持 JavaScript 标准库中的 `setTimeout`、`clearTimeout`、`setInterval`、`clearInterval` 等定时器函数。开发者可以使用这些函数实现延迟执行、周期任务、异步回调等常见需求，语法与浏览器环境和 Node.js 环境完全一致。

Promise 是现代 JavaScript 异步编程的核心抽象，SW Runtime 提供了完整的 Promise/A+ 规范实现，支持 `async/await` 语法糖。所有异步 API 都返回 Promise 对象，开发者可以链式调用 `.then()` 和 `.catch()` 方法处理异步结果，也可以使用 `await` 关键字以同步风格编写异步代码。运行时还支持 `Promise.all()` 和 `Promise.race()` 等并发控制函数，便于管理多个异步操作的执行顺序。

### 3. 脚本打包与加密

对于需要分发的脚本程序，运行时提供了完整的打包工具。该工具从入口文件开始，递归解析所有 `require()` 依赖关系，将整个项目合并为单个 JavaScript 文件。打包过程会自动排除运行时内置的模块（如 `http`、`fs`、`crypto` 等），因为这些模块在运行时已经可用，无需重复打包。

打包工具支持多项高级特性。代码压缩功能可以移除注释、空白字符并进行变量名替换，通常能够减少 70% 以上的代码体积。Source Map 功能可以为压缩后的代码生成调试映射文件，便于在生产环境中进行问题排查。对于需要代码保护的场景，打包工具支持 AES-256-GCM 加密算法对打包后的代码进行加密保护，运行时需要提供正确的解密密钥才能执行加密脚本。

---

## 内置模块详细说明

### 路径模块 (path)

路径模块提供了一系列跨平台的路径操作函数，帮助开发者处理文件路径相关的常见需求。该模块主要包含以下功能：路径拼接函数 `join()` 可以将多个路径片段连接成完整路径，并自动处理不同操作系统之间的路径分隔符差异；路径解析函数 `resolve()` 将相对路径转换为绝对路径；路径归一化函数 `normalize()` 可以清除路径中的冗余成分，如 `./`、`../` 以及重复的分隔符。

模块还提供了路径信息提取函数：`dirname()` 获取文件所在的目录路径，`basename()` 获取文件名（含或不含扩展名），`extname()` 获取文件扩展名，`isAbsolute()` 判断是否为绝对路径，`relative()` 计算两个路径之间的相对关系。此外，模块还导出了路径分隔符常量 `sep` 和路径定界符 `delimiter`，便于开发者进行路径相关的条件判断。

### 文件系统模块 (fs)

文件系统模块提供了对本地文件系统进行读写操作的能力，支持同步和异步两种调用方式。同步 API 以 `Sync` 结尾，执行时会阻塞当前协程直到操作完成，适合启动初始化、配置读取等场景；异步 API 返回 Promise，适合处理大文件、网络请求等耗时操作。

核心读取函数 `readFile()` 和 `readFileSync()` 用于读取文件内容，支持指定编码格式（默认为 UTF-8），返回值是文件内容的字符串形式。写入函数 `writeFile()` 和 `writeFileSync()` 用于创建或覆盖文件，支持指定写入内容和编码格式。追加写入可以使用 `appendFile()` 函数。

目录操作函数包括：`mkdir()` 创建目录（支持递归创建多级目录），`readdir()` 读取目录内容并返回文件名数组，`rmdir()` 删除空目录。文件操作函数包括：`unlink()` 删除文件，`copyFile()` 复制文件，`rename()` 重命名或移动文件，`stat()` 获取文件元信息（大小、修改时间、是否为目录等），`exists()` 检查文件或目录是否存在。

### 加密模块 (crypto)

加密模块提供了完整的加解密和哈希功能，满足数据传输加密、数据完整性校验、敏感信息存储等安全需求。哈希函数支持 MD5、SHA1、SHA256、SHA512 四种算法，均接受字符串输入并返回十六进制格式的哈希值。MD5 算法适用于快速校验场景，SHA 系列算法适用于安全敏感场景，其中 SHA256 在大多数情况下提供了足够的安全性。

编解码功能支持 Base64 和 Hex 两种格式：`base64Encode()` 和 `base64Decode()` 用于 Base64 格式的转换，`hexEncode()` 和 `hexDecode()` 用于十六进制格式的转换。这些功能在处理二进制数据、网络传输、密钥存储等场景中非常实用。

对称加密采用 AES-256-GCM 算法，该算法同时提供加密和认证功能，可以检测数据是否被篡改。`aesEncrypt()` 函数接受明文和密钥，返回 Base64 编码的密文；`aesDecrypt()` 函数接受密文和密钥，返回原始明文。随机数生成函数 `randomBytes()` 可以生成指定长度的安全随机字节序列，适用于生成密钥、初始化向量、会话标识等场景。

### 压缩模块 (compression/zlib)

压缩模块实现了 Gzip 和 Zlib 两种压缩算法，用于减少数据传输量和存储空间占用。Gzip 是 HTTP 压缩中最常用的格式，Zlib 是其底层算法实现，两者都采用 DEFLATE 压缩算法。

`gzipCompress()` 函数接受原始数据字符串，返回 Base64 编码的压缩数据；`gzipDecompress()` 执行相反的操作。Zlib 格式的压缩和解压分别由 `zlibCompress()` 和 `zlibDecompress()` 函数实现。压缩后的数据采用 Base64 编码是为了确保二进制数据可以作为字符串安全传输和存储，在实际应用中通常还会配合加密模块对压缩数据进行保护。

### HTTP 客户端模块 (http)

HTTP 客户端模块提供了发送 HTTP 请求的能力，支持 GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS 七种标准 HTTP 方法。所有请求方法都是异步的，返回 Promise 对象，请求参数和响应数据都支持自动 JSON 序列化与反序列化。

请求配置对象支持丰富的选项：请求头可以通过 `headers` 字段设置，请求体数据通过 `data` 字段传递（自动序列化为 JSON），URL 查询参数通过 `params` 字段设置（自动拼接到 URL 后），超时时间通过 `timeout` 字段设置（单位为秒）。认证支持两种方式：基础认证通过 `auth.username` 和 `auth.password` 设置，Bearer Token 认证通过 `auth.token` 设置。

拦截器功能允许开发者在请求发送前和响应接收后进行自定义处理。请求拦截器可以统一添加认证信息、日志记录、请求参数修改等逻辑；响应拦截器可以统一处理错误码、转换响应数据格式、记录响应时间等。运行时还支持创建多个 HTTP 客户端实例，每个实例可以拥有独立的配置和拦截器。

### HTTP/HTTPS 服务器模块 (httpserver/server)

HTTP 服务器模块提供了创建 HTTP/HTTPS 服务端应用的能力，支持完整的请求处理、中间件机制、路由管理、静态文件服务、WebSocket 通信等功能。该模块采用 Express 风格的 API 设计，对于有 Node.js 开发经验的工程师来说学习成本极低。

创建服务器使用 `createServer()` 函数，返回一个 HTTPServer 实例。服务器实例通过 `listen()` 方法启动 HTTP 监听，通过 `listenTLS()` 方法启动 HTTPS 监听（需要提供 SSL 证书和私钥文件路径）。所有启动方法都返回 Promise，监听成功后会解析为启动信息字符串。

路由注册支持标准 HTTP 方法：`get()`、`post()`、`put()`、`delete()` 分别注册对应方法的处理函数，路由路径支持参数占位符（如 `/users/:id`）。中间件通过 `use()` 函数注册，中间件函数接收请求对象 `req`、响应对象 `res` 和 `next` 函数作为参数，可以在处理链中执行日志记录、身份验证、请求修改等操作。

响应对象 `res` 提供了丰富的输出方法：`send()` 发送文本响应，`json()` 发送 JSON 响应（自动序列化），`html()` 发送 HTML 响应，`sendFile()` 发送文件（自动检测 MIME 类型），`download()` 发送文件下载响应，`redirect()` 执行重定向，`status()` 设置响应状态码，`header()` 设置响应头。

静态文件服务通过 `static()` 方法配置，指定本地目录和 URL 前缀后，运行时自动处理文件读取、MIME 类型检测、缓存头设置等逻辑。WebSocket 支持通过 `ws()` 方法配置，WebSocket 处理函数接收一个 WebSocket 连接对象，该对象支持 `send()` 发送消息、`on()` 监听事件等操作。

### WebSocket 模块 (websocket/ws)

WebSocket 模块提供了作为客户端连接到远程 WebSocket 服务器的能力，补充了 HTTP 服务器模块内置的 WebSocket 服务端功能。`connect()` 函数接受 WebSocket URL（ws:// 或 wss://）和可选的连接选项，返回一个 Promise，解析为 WebSocket 客户端对象。

连接选项支持设置连接超时时间、自定义 HTTP 请求头、WebSocket 子协议等。客户端对象的核心方法包括：`send()` 发送文本消息，`sendJSON()` 发送 JSON 消息（自动序列化），`sendBinary()` 发送二进制数据，`ping()` 发送心跳帧，`close()` 关闭连接，`isClosed()` 检查连接状态。

事件监听通过 `on()` 方法实现，支持四类事件：`message` 事件在收到消息时触发，回调参数是消息内容；`close` 事件在连接关闭时触发；`error` 事件在发生错误时触发，回调参数是错误信息对象；`pong` 事件在收到服务端心跳响应时触发。

### 网络模块 (net)

网络模块提供了 TCP 和 UDP 两种传输层协议的低级编程接口，适用于需要自定义协议或高性能网络通信的场景。

TCP 功能包括创建服务器和建立连接两个方面。`createTCPServer()` 创建 TCP 服务器实例，通过 `listen()` 方法启动监听，通过 `on('connection')` 事件获取客户端连接。连接建立后获得的 TCPSocket 对象支持 `write()` 发送数据、`on('data')` 接收数据、`close()` 关闭连接等操作。`connectTCP()` 函数用于作为客户端连接到 TCP 服务器。

UDP 功能围绕 UDPSocket 对象展开。`createUDPSocket()` 创建 UDP 套接字实例，通过 `bind()` 方法绑定到本地端口和地址，通过 `send()` 方法发送数据报，通过 `on('message')` 事件接收传入的数据报。UDP 是无连接协议，每次发送都需要指定目标地址和端口。

### 代理模块 (proxy)

代理模块实现了 HTTP 反向代理和 TCP 透明代理两种代理模式，可用于请求转发、负载均衡、服务路由、流量监控等场景。

HTTP 代理通过 `createHTTPProxy()` 函数创建，参数是目标服务器的 URL。代理服务器启动后会监听指定端口，转发所有请求到目标服务器，并返回目标服务器的响应。开发者可以通过 `on('request')` 事件拦截请求信息，通过 `on('response')` 事件拦截响应信息，通过 `on('error')` 事件处理代理过程中的错误。

TCP 代理通过 `createTCPProxy()` 函数创建，参数是目标服务器地址（host:port）。TCP 代理工作在传输层，将客户端连接透明地转发到目标服务器，不解析应用层协议。`on('connection')` 事件在每次代理连接建立时触发，`on('data')` 事件在数据传输时触发（可以获取传输方向和字节数），`on('close')` 事件在连接关闭时触发。

### Redis 客户端模块 (redis)

Redis 客户端模块提供了连接 Redis 数据库并执行各类数据操作的能力。Redis 是高性能的内存键值数据库，常用于缓存、会话存储、消息队列、实时计数等场景。

创建客户端使用 `createClient()` 函数，配置对象支持 `host`、`port`、`password`、`db` 等参数。客户端支持丰富的数据类型操作：字符串类型的 `set()`、`get()`、`del()`、`exists()`、`expire()`、`ttl()` 方法；哈希类型的 `hset()`、`hget()`、`hgetall()`、`hdel()`、`hexists()`、`hkeys()`、`hvals()` 方法；列表类型的 `lpush()`、`rpush()`、`lpop()`、`rpop()`、`lrange()`、`llen()` 方法；集合类型的 `sadd()`、`srem()`、`smembers()`、`sismember()`、`scard()` 方法；有序集合类型的 `zadd()`、`zrange()`、`zscore()`、`zcard()` 方法。

模块还提供了 JSON 数据的原生支持：`setJSON()` 自动将对象序列化为 JSON 字符串存储，`getJSON()` 自动将存储的 JSON 字符串反序列化为对象。这使得开发者可以直接在 Redis 中存储和读取复杂的 JavaScript 对象，无需手动处理序列化逻辑。

### SQLite 数据库模块 (sqlite)

SQLite 数据库模块提供了创建和管理 SQLite 数据库的能力。SQLite 是轻量级的嵌入式关系型数据库，整个数据库存储在单个文件中，无需独立的数据库服务器进程，适合桌面应用、移动应用、嵌入式系统、小型网站等场景。

打开数据库使用 `open()` 函数，参数是数据库文件路径，特殊路径 `:memory:` 表示创建内存数据库（数据仅在程序运行期间存在）。数据库对象提供了完整的 SQL 执行能力：`exec()` 执行不需要返回结果的 SQL 语句（如创建表、修改表结构）；`run()` 执行 INSERT、UPDATE、DELETE 语句，返回插入 ID 和影响行数；`get()` 查询单条记录；`all()` 查询多条记录。

预处理语句通过 `prepare()` 方法创建，可以预编译 SQL 模板并多次执行，提高执行效率并防止 SQL 注入攻击。事务支持通过 `transaction()` 方法实现，传入一个异步回调函数作为事务逻辑，回调函数接收一个事务对象作为参数，在事务中执行的所有 SQL 语句要么全部成功提交，要么全部回滚。

数据库元信息查询功能包括：`tables()` 返回数据库中所有表的名称列表，`schema()` 返回指定表的结构信息（列名、数据类型、是否主键等）。

### 进程执行模块 (exec/child_process)

进程执行模块提供了在运行时环境中执行外部命令的能力，可以调用系统命令、运行其他可执行程序、实现与系统 Shell 的交互等功能。

同步执行使用 `execSync()` 函数，会阻塞当前协程直到命令执行完成并返回结果。异步执行使用 `exec()` 函数，返回 Promise 对象，不阻塞程序执行。两种执行方式都接受命令名称、可选的参数数组和可选的配置对象作为参数。

执行结果对象包含以下字段：`stdout` 标准输出内容，`stderr` 标准错误内容，`exitCode` 退出码，`success` 是否成功执行，`error` 错误信息（如果发生），`command` 执行的完整命令字符串，`args` 命令参数数组。异步执行时结果对象还会包含 `timedOut` 字段表示是否因超时而终止。

配置对象支持设置工作目录 `cwd`、环境变量 `env`、超时时间 `timeout`（毫秒）。环境变量操作函数 `getEnv()` 和 `setEnv()` 分别用于读取和修改当前进程的环境变量。命令查找函数 `which()` 返回命令的完整路径，`commandExists()` 检查命令是否存在。

### 时间处理模块 (time)

时间处理模块提供了获取当前时间、解析时间字符串、格式化时间戳、时间计算与比较等功能，是处理时间相关业务逻辑的基础模块。

时间获取函数包括：`now()` 返回 ISO 8601 格式的当前时间字符串，`nowUnix()` 返回当前 Unix 时间戳（秒），`nowUnixMilli()` 返回毫秒级时间戳，`nowUnixNano()` 返回纳秒级时间戳。

时间解析与格式化函数：`parse()` 解析时间字符串为时间对象（包含年、月、日、时、分、秒、星期等信息），`format()` 将 Unix 时间戳格式化为指定格式的字符串。模块预定义了一组格式常量：`FORMAT.RFC3339`、`FORMAT.DateTime`、`FORMAT.Date`、`FORMAT.Time` 等，满足大多数常见的时间显示需求。

时间计算函数支持对时间戳进行加减运算：`add()` 添加纳秒级时间间隔，`addDays()`、`addHours()`、`addMinutes()`、`addSeconds()` 分别添加指定数量的天、小时、分钟、秒。时间比较函数 `isBefore()` 和 `isAfter()` 判断两个时间点的先后关系，`diff()` 计算两个时间点之间的差值。

延迟执行函数：`sleep()` 延迟指定秒数后继续执行，`sleepMillis()` 延迟指定毫秒数后继续执行，两者都返回 Promise。

定时器函数：`setInterval()` 创建周期性定时器，返回定时器 ID，`clearInterval()` 清除定时器。`createTicker()` 创建 Ticker 对象，提供 `tick()` 注册回调、`stop()` 停止、`reset()` 重置间隔等方法。

时间组件获取函数：`getYear()`、`getMonth()`、`getDay()`、`getHour()`、`getMinute()`、`getSecond()` 分别从时间戳中提取对应的时间组件。`getWeekday()` 返回星期几信息。

---

## 命令行工具

SW Runtime 提供了功能完整的命令行工具，入口程序名为 `sw_runtime`，支持以下命令：

**run 命令**用于执行脚本文件。`sw_runtime run app.ts` 运行 TypeScript 脚本，`sw_runtime run app.js` 运行 JavaScript 脚本。`--clear-cache` 选项可以清除模块缓存后执行，这在开发和调试模块加载问题时很有用。`--watch` 或 `-w` 选项启用热重载模式，运行时会在脚本文件修改后自动重新加载执行。

**eval 命令**用于直接执行代码片段。`sw_runtime eval "console.log('Hello')"` 会立即输出 Hello 字符串。这个功能适合快速测试代码片段、验证 API 用法、执行简单计算等场景。

**bundle 命令**用于打包脚本项目。`sw_runtime bundle app.js` 将入口文件和所有依赖打包为单个文件。`-o` 选项指定输出文件路径，`--minify` 选项启用代码压缩，`--sourcemap` 选项生成调试映射文件，`--exclude` 选项排除指定文件（逗号分隔），`--encrypt` 选项启用代码加密。

**version 命令**显示运行时版本信息。**info 命令**显示运行时详细信息，包括内置模块列表、运行时配置等。**--help** 选项显示帮助信息，**--verbose** 或 **-v** 选项启用详细输出模式，**--quiet** 或 **-q** 选项启用静默模式（减少输出信息）。

---

## 技术架构

SW Runtime 的核心架构分为三层：底层是 Go 语言运行时，提供了优秀的并发模型和内存管理能力；中层是 goja 引擎，实现了 ECMAScript 标准的 JavaScript 解释执行；上层是内置模块系统，封装了各类系统功能的 JavaScript 接口。

模块系统采用混合设计，同时支持 CommonJS 的 `require()` 语法和 ES6 的 `import()` 语法。模块加载时会自动解析依赖关系，建立模块缓存以避免重复加载。对于 TypeScript 文件，模块系统会调用内置的 transpiler 进行即时编译，将 TypeScript 转换为 JavaScript 后再执行。

异步执行基于 Go 协程实现，每个异步操作在 Go 层面运行于独立的协程中，通过事件循环机制与 JavaScript 运行时进行数据交换和状态同步。这种设计既保证了异步操作的高效执行，又确保了 JavaScript 代码的单线程执行语义不会被打乱。

---

## 适用场景

SW Runtime 适用于多种应用场景。在微服务开发领域，开发者可以使用 JavaScript/TypeScript 编写轻量级的 API 服务，利用内置的 HTTP 服务器、数据库客户端、缓存客户端等功能快速构建业务逻辑。在嵌入式脚本领域，独立运行的二进制文件可以嵌入到其他应用中作为配置脚本、扩展脚本或自动化脚本的执行引擎。

在自动化运维领域，运行时可以执行各类运维脚本，包括文件处理、数据同步、系统监控、告警通知等任务。在数据处理领域，内置的加密模块、压缩模块、数据库模块可以组合使用，构建高效的数据处理流水线。在代理服务领域，内置的 HTTP 代理和 TCP 代理功能可以快速搭建各类代理服务。

相比 Node.js 运行时，SW Runtime 的主要优势在于：更小的二进制文件体积（仅数 MB），更低的运行时资源占用，无需安装 Node.js 环境即可运行，支持静态编译和代码加密保护。这些特性使得 SW Runtime 特别适合容器化部署、边缘计算、设备端脚本等资源受限或安全性要求较高的场景。
